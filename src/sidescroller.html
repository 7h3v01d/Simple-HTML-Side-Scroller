<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Side-Scroller</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: 'Courier New', Courier, monospace;
            text-align: center;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        canvas {
            background-color: #333;
            border: 2px solid #fff;
        }
        h1 {
            margin-bottom: 10px;
        }
        p {
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>Simple Side-Scroller</h1>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    <p>Controls: [Arrow Keys] to Move & Jump | [Spacebar] to Shoot</p>
    <p id="gameStateText"></p>

    <script>
        // --- Basic Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameStateText = document.getElementById('gameStateText');

        // --- Game Constants & State ---
        const GRAVITY = 0.6;
        const PLAYER_SPEED = 5;
        const JUMP_FORCE = -15;
        const PROJECTILE_SPEED = 10;
        
        let isGameOver = false;
        let gameWon = false;
        let score = 0;

        // --- Game Objects ---
        const player = {
            x: 100, y: 200,
            width: 40, height: 60,
            dx: 0, dy: 0,
            onGround: false,
            color: '#3498db'
        };

        const projectiles = [];
        let enemies = [];
        const platforms = [];
        const levelWidth = 2000; // Make the level wider than the canvas

        // --- Camera ---
        const camera = {
            x: 0,
            y: 0,
            width: canvas.width,
            height: canvas.height
        };

        // --- Input Handling ---
        const keys = {
            left: false,
            right: false,
            up: false,
            space: false
        };

        window.addEventListener('keydown', (e) => {
            if (isGameOver || gameWon) return;
            switch(e.code) {
                case 'ArrowLeft': keys.left = true; break;
                case 'ArrowRight': keys.right = true; break;
                case 'ArrowUp': 
                    if (player.onGround) {
                        player.dy = JUMP_FORCE;
                        player.onGround = false;
                    }
                    break;
                case 'Space': shoot(); break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'ArrowLeft': keys.left = false; break;
                case 'ArrowRight': keys.right = false; break;
            }
        });

        // --- Game Logic Functions ---
        function shoot() {
            projectiles.push({
                x: player.x + player.width / 2,
                y: player.y + player.height / 2,
                width: 10,
                height: 5,
                dx: PROJECTILE_SPEED,
                color: '#f1c40f'
            });
        }
        
        function createLevel() {
            // Reset state for new game
            player.x = 100; player.y = 200; player.dy = 0;
            projectiles.length = 0;
            enemies.length = 0;
            platforms.length = 0;
            isGameOver = false;
            gameWon = false;
            gameStateText.innerText = "";

            // Ground
            platforms.push({ x: 0, y: canvas.height - 20, width: levelWidth, height: 20, color: '#2ecc71' });
            
            // Floating platforms
            platforms.push({ x: 250, y: 300, width: 150, height: 20, color: '#2ecc71' });
            platforms.push({ x: 500, y: 250, width: 150, height: 20, color: '#2ecc71' });
            platforms.push({ x: 800, y: 200, width: 200, height: 20, color: '#2ecc71' });
            platforms.push({ x: 1100, y: 300, width: 100, height: 20, color: '#2ecc71' });
            platforms.push({ x: 1400, y: 250, width: 250, height: 20, color: '#2ecc71' });
            
            // Enemies
            enemies.push({ x: 525, y: 200, width: 30, height: 50, color: '#e74c3c' });
            enemies.push({ x: 850, y: 150, width: 30, height: 50, color: '#e74c3c' });
            enemies.push({ x: 1475, y: 200, width: 30, height: 50, color: '#e74c3c' });
        }

        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function update() {
            if (isGameOver || gameWon) {
                 if (isGameOver) {
                    gameStateText.innerText = "GAME OVER! Click to Restart.";
                } else {
                    gameStateText.innerText = "YOU WIN! Click to Restart.";
                }
                return;
            }

            // --- Player Movement ---
            player.dx = 0;
            if (keys.left) player.dx = -PLAYER_SPEED;
            if (keys.right) player.dx = PLAYER_SPEED;
            
            player.x += player.dx;
            player.dy += GRAVITY;
            player.y += player.dy;
            player.onGround = false;

            // --- Collision Detection ---
            // Player vs Platforms
            platforms.forEach(platform => {
                if (isColliding(player, platform) && player.dy > 0) {
                    // Check if player was above the platform in the previous frame
                    if (player.y + player.height - player.dy <= platform.y) {
                         player.y = platform.y - player.height;
                         player.dy = 0;
                         player.onGround = true;
                    }
                }
            });

            // Keep player within level bounds
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > levelWidth) player.x = levelWidth - player.width;

            // Player vs Enemies
            enemies.forEach(enemy => {
                if (isColliding(player, enemy)) {
                    isGameOver = true;
                }
            });
            
            // --- Projectiles ---
            projectiles.forEach((proj, projIndex) => {
                proj.x += proj.dx;
                // Remove projectiles that go off-screen
                if (proj.x > camera.x + canvas.width) {
                    projectiles.splice(projIndex, 1);
                }

                // Projectiles vs Enemies
                enemies.forEach((enemy, enemyIndex) => {
                    if (isColliding(proj, enemy)) {
                        enemies.splice(enemyIndex, 1);
                        projectiles.splice(projIndex, 1);
                    }
                });
            });

            // --- Update Camera ---
            // Center camera on player, but don't go past level edges
            camera.x = player.x - canvas.width / 2;
            if (camera.x < 0) camera.x = 0;
            if (camera.x > levelWidth - canvas.width) camera.x = levelWidth - canvas.width;

            // --- Check Win Condition ---
            if (enemies.length === 0) {
                gameWon = true;
            }

            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply camera translation
            ctx.save();
            ctx.translate(-camera.x, 0);

            // Draw game objects
            platforms.forEach(p => { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.width, p.height); });
            enemies.forEach(e => { ctx.fillStyle = e.color; ctx.fillRect(e.x, e.y, e.width, e.height); });
            projectiles.forEach(p => { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.width, p.height); });
            
            // Draw player
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);

            ctx.restore();
        }

        // --- Game Start ---
        canvas.addEventListener('click', () => {
            if (isGameOver || gameWon) {
                createLevel();
                update();
            }
        });

        createLevel();
        update();

    </script>
</body>
</html>